问题：
* 调度器取任务的时间和分配任务的时间如何确定？\
设置了一套比较合理的逻辑，如下：

* 调度器初次开始工作时，如果暂时没有任务需要处理该怎么办？调度器在启动后，是首次到来任务前一直轮询还是设置一个休眠机制？如何保证一个间隔时间短的任务能够及时被调度执行呢？
    1. 内存中没有job需要分配时，进入休眠状态
    2. fetchJob协程从reids中取出任务后通过chan发送信息，唤醒调度器
    3. 调度器开始工作
    4. 循环上述过程

* 调度器在工作的过程中，客户端插入了一条新的定时任务，该如何处理？
    1. 该任务的执行时间在当前时间之前，判断为无效的请求，直接丢弃
    2. 该任务的执行时间在当前调度的时间段内，立即开始分配该任务
    3. 该任务的执行时间在下一个调度的时间段内，将其插入小根堆中
    4. 其他情况下，不放入小根堆中，先放入redis调度列表中等待时间到来开始调度
    > 以上2，3，4情况，都需要将job的信息存入redis的哈希表中\
    > 后续：直接把2，3情况合并为一种了

* 具体的精确的时间逻辑不太好写，每个函数或者每条指令的执行时间是不确定的，只能按照大概的时间来进行任务的调度和执行，但是需要提前分配任务，以提前解决通信开销等，保证任务在预期的时间开始执行
    > 采用的方法是提前1/10个Interval的时间开始取任务，取完任务后立即开始分配任务，但是可能存在问题，如果当此次调度需要取的任务数相当大而Interval相当小时，可能会导致错过任务的执行时间，这里不予考虑了，假定不会发生这种情况（实际上我的Interval一般是分钟级或者小时级的）

* grpc同一端口上注册两个服务发生问题，程序阻塞在Serve处，debug后还是没有找到问题，以为是端口冲突问题，后修改代码将两个服务注册到同一端口上，依然阻塞，后发现Server操作本身是阻塞的，将其放入goroutine中解决问题

* 结构体中带指针或者数组时，直接初始化结构体会创建空指针，后续访问该地址时会发生空指针错误（没有构造函数的功能），需要在初始化时手动为变量分配空间

* 初始化map时一定要有make，map的初始值不是空map，而是一个nil值
* 定义chan时同理，但是更没想到的一点是向一个没有分配空间的chan传递数据时，程序会阻塞，不会报错（气死了，这里卡了好久）

* 对于grpc的服务注册也存在一些误解，初次使用感觉有点绕圈子的意思

* 编码过程一定要仔细，Unlock写成了Lock，程序死锁检测不出来（写在http的处理里面的，curl URI后命令行没反应，以为是哪个部分逻辑出问题了到处打日志找，后面不小心一眼瞟到这里才发现的），浪费一下午
![Alt text](/pictures/genius.png)


> 调度器的逻辑要改，不能把循环交给worker去执行，worker只负责执行任务，所有循环由scheduler判断并分配

可靠性方面：
* 如果worker宕机了，worker上正在运行的定时任务该怎么处理？
    1. 检测到worker宕机需要一个超时时间，job有一个nextExecTime，需要考虑这两个时间的关系
        1. 当检测到超时的时候，有某个任务的nextExecTime在当前时间之前怎么处理
        2. 刚好在当前时间怎么处理
        3. 在当前时间之后相当于插入一个newjob，直接按照newjob到达的方式处理即可

    2. 如何维护job的nextExecTime，在worker宕机之后可以让scheduler知道job的nextExecTime
        1. worker每次调度后将job的nextExecTime上报etcd，scheduler届时直接从etcd中读出
        2. worker记录在redis中，scheduler从redis中读出，但是从redis中读出的话会有另外的读写冲突问题
        3. worker用grpc通知scheduler每次的nextExecTime，scheduler记录在内存中（太浪费资源，而且会有额外的通信开销，对系统的性能影响较大）

* begintime在什么时间内的任务可以认为是合法的？ 设置为一小时内

* 关于锁的粒度大小也有一些问题需要考虑，一般来说在保证系统正常的情况下粒度越小越好，此处是将job锁是在worker解锁后再获取的，尽量不影响其他协程（如新worker加入协程——registWorker）的工作
![Alt text](/pictures/3mutex.png)

* 当一个job被调度后，如何感知是否被正确的执行了？用int来标识job的状态，分别有**0：待分配，1：已分配未执行，2：已分配正执行，3：已完成**4种。
    1. 对于循环任务，为该任务开启一个定时器，间隔设定为**1/2循环时间**，如果检测时任务的状态没有变成3，则立即重新调度一次，反之删除定时器，结束该任务的本轮调度；
    2. 对于单次任务，处理同上，将定时器时间设定为一个**固定时间**，如1min；
    3. 这样处理可以不用为每次调度的任务新增一个结构体数组来进行管理，在JobInfo中添加一个状态成员即可，减少了额外处理的开销，也不会与下一次调度时的任务发生冲突，因为检查时间肯定在下一次调度之前。

* 如何避免单点故障和恢复任务执行？
    1. 用id唯一标识每个任务，对于一个任务，在加入到调度队列中时，为其添加ID到JobInfo的映射；
    2. 在分配任务时，为其添加ID到WorkerInfo的映射，并在WorkerInfo中添加其正在执行的所有任务ID；
    3. 当一个job的watcher结束，删除其对应的映射表，并在执行该任务的worker中删除该任务记录；
    4. 当worker发生故障宕机时，可以从其对应的WorkerInfo中取出所有的jobID，将其分配给其他worker执行即可。


## 问题记录
![Alt text](/pictures/11-28.png)

![Alt text](/pictures/failed.png)

![Alt text](/pictures/timeout.png)

![Alt text](/pictures/time_wrong.png)
